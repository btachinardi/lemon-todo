#!/usr/bin/env bash
# ─────────────────────────────────────────────────────────────────────
# LemonDo Developer CLI
# Usage: ./dev <command> [options]
# ─────────────────────────────────────────────────────────────────────
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "$0")" && pwd)"
SLN="$ROOT_DIR/src/LemonDo.slnx"
CLIENT_DIR="$ROOT_DIR/src/client"
E2E_DIR="$ROOT_DIR/tests/e2e"
API_PROJECT="$ROOT_DIR/src/LemonDo.Api"
APPHOST_PROJECT="$ROOT_DIR/src/LemonDo.AppHost"
MIGRATIONS_SQLITE="$ROOT_DIR/src/LemonDo.Migrations.Sqlite"
MIGRATIONS_SQLSERVER="$ROOT_DIR/src/LemonDo.Migrations.SqlServer"
INFRA_DIR="$ROOT_DIR/infra"
TEST_RESULTS_DIR="$ROOT_DIR/.test-results"
DEFAULT_STAGE="stage1-mvp"

# Default SQL Server connection for local Docker
DEFAULT_SQL_CONN='Server=localhost,1433;Database=LemonDoTests;User Id=sa;Password=YourStr0ngPassw0rd;TrustServerCertificate=True;'

# ── Colors ────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

header()  { echo -e "\n${CYAN}${BOLD}=== $1 ===${NC}\n"; }
success() { echo -e "${GREEN}$1${NC}"; }
warn()    { echo -e "${YELLOW}$1${NC}"; }
err()     { echo -e "${RED}$1${NC}" >&2; }

# ── Tool detection helpers ───────────────────────────────────────────
# Dynamically locate Azure CLI — checks PATH first, then common install locations
find_az() {
  if command -v az &>/dev/null; then
    echo "az"
    return
  fi

  local candidates=(
    "/c/Program Files/Microsoft SDKs/Azure/CLI2/wbin/az.cmd"
    "/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/wbin/az.cmd"
    "$HOME/.local/bin/az"
    "/usr/local/bin/az"
    "/opt/homebrew/bin/az"
  )

  for candidate in "${candidates[@]}"; do
    if [ -f "$candidate" ]; then
      echo "$candidate"
      return
    fi
  done

  err "Azure CLI (az) not found."
  echo "  Install: https://learn.microsoft.com/en-us/cli/azure/install-azure-cli"
  exit 1
}

find_terraform() {
  if command -v terraform &>/dev/null; then
    echo "terraform"
    return
  fi

  local candidates=(
    "/c/ProgramData/chocolatey/bin/terraform.exe"
    "$HOME/.local/bin/terraform"
    "/usr/local/bin/terraform"
    "/opt/homebrew/bin/terraform"
  )

  for candidate in "${candidates[@]}"; do
    if [ -f "$candidate" ]; then
      echo "$candidate"
      return
    fi
  done

  err "Terraform not found."
  echo "  Install: https://developer.hashicorp.com/terraform/install"
  exit 1
}

# Run terraform with MSYS2 path conversion disabled (prevents /subscriptions/ → C:/Program Files/Git/...)
run_terraform() {
  local tf
  tf="$(find_terraform)"
  MSYS_NO_PATHCONV=1 "$tf" "$@"
}

# Ensure Azure CLI is authenticated
ensure_az_login() {
  local az_cmd
  az_cmd="$(find_az)"
  if ! "$az_cmd" account show &>/dev/null; then
    err "Not logged into Azure. Run:"
    echo "  az login"
    exit 1
  fi
}

# Add Azure CLI to PATH if not already there (for tools like terraform that shell out to az)
setup_az_path() {
  if command -v az &>/dev/null; then
    return
  fi

  local az_cmd
  az_cmd="$(find_az)"
  local az_dir
  az_dir="$(dirname "$az_cmd")"
  export PATH="$az_dir:$PATH"
}

# ── Test result helpers ───────────────────────────────────────────────
# Prune TRX files older than 24 hours.
cleanup_old_test_results() {
  if [ -d "$TEST_RESULTS_DIR" ]; then
    find "$TEST_RESULTS_DIR" -name "*.trx" -mmin +1440 -delete 2>/dev/null || true
    find "$TEST_RESULTS_DIR" -mindepth 1 -type d -empty -delete 2>/dev/null || true
  fi
  mkdir -p "$TEST_RESULTS_DIR"
}

# Discover test projects from the solution and run each with per-project TRX output.
# Convention: project name "LemonDo.Foo.Tests" → results dir ".test-results/Foo"
run_backend_tests() {
  local projects
  projects=$(dotnet sln "$SLN" list 2>/dev/null | grep '\.Tests\.csproj$')
  local failed=0

  while IFS= read -r rel_path; do
    [ -z "$rel_path" ] && continue
    # rel_path is relative to src/ dir (e.g. ..\tests\LemonDo.Api.Tests\LemonDo.Api.Tests.csproj)
    local project_dir
    project_dir="$ROOT_DIR/src/$rel_path"
    # Normalize path (resolve ..\)
    project_dir="$(cd "$(dirname "$project_dir")" 2>/dev/null && pwd)"

    # Derive short name: LemonDo.Api.Tests → Api
    local dir_name
    dir_name="$(basename "$project_dir")"
    local short_name
    short_name="${dir_name#LemonDo.}"   # strip LemonDo. prefix
    short_name="${short_name%.Tests}"    # strip .Tests suffix

    mkdir -p "$TEST_RESULTS_DIR/$short_name"
    dotnet test --project "$project_dir" --report-trx --results-directory "$TEST_RESULTS_DIR/$short_name" "$@" || failed=1
  done <<< "$projects"

  return $failed
}

# ── SQL Server helpers ────────────────────────────────────────────────
sql_conn() {
  echo "${TEST_SQLSERVER_CONNECTION_STRING:-$DEFAULT_SQL_CONN}"
}

ensure_sql_server() {
  if ! docker ps --format '{{.Names}}' 2>/dev/null | grep -q 'lemondo-sqlserver'; then
    err "SQL Server container 'lemondo-sqlserver' is not running."
    echo ""
    echo "Start it with:"
    echo "  docker run -d --name lemondo-sqlserver \\"
    echo "    -e 'ACCEPT_EULA=Y' \\"
    echo "    -e 'MSSQL_SA_PASSWORD=YourStr0ngPassw0rd' \\"
    echo "    -p 1433:1433 \\"
    echo "    mcr.microsoft.com/mssql/server:2022-latest"
    exit 1
  fi
}

# ── Commands ──────────────────────────────────────────────────────────

cmd_install() {
  header "Installing all dependencies"

  echo -e "${BOLD}[1/6] HTTPS development certificate${NC}"
  dotnet dev-certs https 2>/dev/null || true
  success "  Done"

  echo -e "\n${BOLD}[2/6] .NET packages (dotnet restore)${NC}"
  dotnet restore "$SLN"
  success "  Done"

  echo -e "\n${BOLD}[3/6] Frontend packages (pnpm install)${NC}"
  (cd "$CLIENT_DIR" && pnpm install)
  success "  Done"

  echo -e "\n${BOLD}[4/6] E2E packages (pnpm install)${NC}"
  (cd "$E2E_DIR" && pnpm install)
  success "  Done"

  echo -e "\n${BOLD}[5/6] Development configuration files${NC}"
  setup_dev_config
  success "  Done"

  echo -e "\n${BOLD}[6/6] Generate TypeScript API types${NC}"
  (cd "$CLIENT_DIR" && pnpm generate:api)
  success "  Done"

  echo ""
  success "All dependencies installed and configured!"
}

# Generate gitignored development config files (safe dev defaults, no real secrets)
setup_dev_config() {
  local api_dir="$ROOT_DIR/src/LemonDo.Api"
  local apphost_dir="$ROOT_DIR/src/LemonDo.AppHost"

  # ── API appsettings.Development.json ──
  local api_dev_settings="$api_dir/appsettings.Development.json"
  if [ ! -f "$api_dev_settings" ]; then
    cat > "$api_dev_settings" << 'APIJSON'
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Debug",
      "Override": {
        "Microsoft.AspNetCore": "Information",
        "Microsoft.AspNetCore.Routing": "Warning",
        "Microsoft.EntityFrameworkCore": "Warning",
        "System.Net.Http.HttpClient": "Warning"
      }
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=lemondo.db"
  },
  "Features": {
    "EnableDemoAccounts": true
  },
  "Encryption": {
    "FieldEncryptionKey": "ZGV2LW9ubHktZmllbGQtZW5jcnlwdGlvbi1rZXktMzI="
  },
  "Jwt": {
    "Issuer": "LemonDo",
    "Audience": "LemonDo",
    "SecretKey": "dev-secret-key-at-least-32-characters-long!!",
    "AccessTokenExpirationMinutes": 15,
    "RefreshTokenExpirationDays": 7
  }
}
APIJSON
    echo "  Created $api_dev_settings"
  else
    echo "  Skipped $api_dev_settings (already exists)"
  fi

  # ── API launchSettings.json ──
  local api_launch="$api_dir/Properties/launchSettings.json"
  if [ ! -f "$api_launch" ]; then
    mkdir -p "$api_dir/Properties"
    cat > "$api_launch" << 'APILAUNCH'
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5155",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "https://localhost:7291;http://localhost:5155",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
APILAUNCH
    echo "  Created $api_launch"
  else
    echo "  Skipped $api_launch (already exists)"
  fi

  # ── AppHost appsettings.Development.json ──
  local apphost_dev_settings="$apphost_dir/appsettings.Development.json"
  if [ ! -f "$apphost_dev_settings" ]; then
    cat > "$apphost_dev_settings" << 'APPHOSTJSON'
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
APPHOSTJSON
    echo "  Created $apphost_dev_settings"
  else
    echo "  Skipped $apphost_dev_settings (already exists)"
  fi

  # ── AppHost launchSettings.json ──
  local apphost_launch="$apphost_dir/Properties/launchSettings.json"
  if [ ! -f "$apphost_launch" ]; then
    mkdir -p "$apphost_dir/Properties"
    cat > "$apphost_launch" << 'APPHOSTLAUNCH'
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:17022;http://localhost:15082",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:21134",
        "ASPIRE_DASHBOARD_MCP_ENDPOINT_URL": "https://localhost:23117",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:22258"
      }
    },
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:15082",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "http://localhost:19137",
        "ASPIRE_DASHBOARD_MCP_ENDPOINT_URL": "http://localhost:18189",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "http://localhost:20279"
      }
    }
  }
}
APPHOSTLAUNCH
    echo "  Created $apphost_launch"
  else
    echo "  Skipped $apphost_launch (already exists)"
  fi
}

cmd_build() {
  header "Clean + Build (all projects)"
  dotnet clean "$SLN" -v quiet 2>/dev/null
  dotnet build "$SLN"
}

cmd_test() {
  local target="${1:-all}"
  shift 2>/dev/null || true

  case "$target" in
    all)
      cmd_test backend "$@"
      cmd_test frontend "$@"
      ;;
    backend)
      header "Backend Tests (SQLite)"
      cleanup_old_test_results
      run_backend_tests "$@"
      ;;
    backend:sql)
      header "Backend Tests (SQL Server)"
      ensure_sql_server
      cleanup_old_test_results
      export TEST_DATABASE_PROVIDER=SqlServer
      export TEST_SQLSERVER_CONNECTION_STRING
      TEST_SQLSERVER_CONNECTION_STRING="$(sql_conn)"
      run_backend_tests "$@"
      ;;
    backend:both)
      cmd_test backend "$@"
      cmd_test backend:sql "$@"
      ;;
    frontend)
      header "Frontend Type Check"
      (cd "$CLIENT_DIR" && pnpm exec tsc -b)
      header "Frontend Tests (Vitest)"
      (cd "$CLIENT_DIR" && pnpm test "$@")
      ;;
    e2e)
      header "E2E Tests (Playwright — SQLite)"
      (cd "$E2E_DIR" && pnpm test "$@")
      ;;
    e2e:sql)
      header "E2E Tests (Playwright — SQL Server)"
      ensure_sql_server
      # Override playwright webServer env to use SQL Server
      export DatabaseProvider=SqlServer
      export ConnectionStrings__DefaultConnection
      ConnectionStrings__DefaultConnection="$(sql_conn | sed 's/LemonDoTests/LemonDoE2E/')"
      (cd "$E2E_DIR" && pnpm test "$@")
      ;;
    e2e:headed)
      header "E2E Tests (Playwright — headed)"
      (cd "$E2E_DIR" && pnpm test:headed "$@")
      ;;
    e2e:ui)
      header "E2E Tests (Playwright — UI mode)"
      (cd "$E2E_DIR" && pnpm test:ui "$@")
      ;;
    e2e:update-snapshots)
      header "E2E Tests — Update Snapshots"
      (cd "$E2E_DIR" && pnpm test:update-snapshots "$@")
      ;;
    *)
      err "Unknown test target: $target"
      echo "Usage: ./dev test [all|backend|backend:sql|backend:both|frontend|e2e|e2e:sql|e2e:headed|e2e:ui|e2e:update-snapshots]"
      exit 1
      ;;
  esac
}

cmd_lint() {
  header "Frontend Lint (ESLint)"
  (cd "$CLIENT_DIR" && pnpm lint "$@")
}

cmd_start() {
  local target="${1:-all}"

  case "$target" in
    all)
      header "Starting Full Stack (Aspire)"
      dotnet run --project "$APPHOST_PROJECT"
      ;;
    api)
      header "Starting API"
      dotnet run --project "$API_PROJECT"
      ;;
    frontend)
      header "Starting Frontend"
      (cd "$CLIENT_DIR" && pnpm dev)
      ;;
    *)
      err "Unknown start target: $target"
      echo "Usage: ./dev start [all|api|frontend]"
      exit 1
      ;;
  esac
}

cmd_migrate() {
  local action="${1:-}"
  local name="${2:-}"

  case "$action" in
    add)
      if [ -z "$name" ]; then
        err "Migration name required."
        echo "Usage: ./dev migrate add <MigrationName>"
        exit 1
      fi
      header "Adding SQLite Migration: $name"
      dotnet ef migrations add "$name" \
        --project "$MIGRATIONS_SQLITE" \
        --startup-project "$API_PROJECT"

      header "Adding SQL Server Migration: $name"
      DatabaseProvider=SqlServer dotnet ef migrations add "$name" \
        --project "$MIGRATIONS_SQLSERVER" \
        --startup-project "$API_PROJECT"

      success "Migrations added to both providers."
      ;;
    list)
      local provider="${name:-sqlite}"
      case "$provider" in
        sqlite)
          header "SQLite Migrations"
          dotnet ef migrations list \
            --project "$MIGRATIONS_SQLITE" \
            --startup-project "$API_PROJECT"
          ;;
        sqlserver|sql)
          header "SQL Server Migrations"
          DatabaseProvider=SqlServer dotnet ef migrations list \
            --project "$MIGRATIONS_SQLSERVER" \
            --startup-project "$API_PROJECT"
          ;;
        *)
          err "Unknown provider: $provider"
          echo "Usage: ./dev migrate list [sqlite|sqlserver]"
          exit 1
          ;;
      esac
      ;;
    remove)
      local provider="${name:-}"
      if [ -z "$provider" ]; then
        err "Provider required for remove."
        echo "Usage: ./dev migrate remove <sqlite|sqlserver>"
        exit 1
      fi
      case "$provider" in
        sqlite)
          header "Removing Last SQLite Migration"
          dotnet ef migrations remove \
            --project "$MIGRATIONS_SQLITE" \
            --startup-project "$API_PROJECT"
          ;;
        sqlserver|sql)
          header "Removing Last SQL Server Migration"
          DatabaseProvider=SqlServer dotnet ef migrations remove \
            --project "$MIGRATIONS_SQLSERVER" \
            --startup-project "$API_PROJECT"
          ;;
        *)
          err "Unknown provider: $provider"
          exit 1
          ;;
      esac
      ;;
    *)
      err "Unknown migrate action: $action"
      echo "Usage: ./dev migrate <add|list|remove> [args]"
      exit 1
      ;;
  esac
}

cmd_generate() {
  header "Generate TypeScript Types from OpenAPI"

  echo -e "${BOLD}[1/2] Generating OpenAPI spec (dotnet build)${NC}"
  dotnet build "$API_PROJECT/LemonDo.Api.csproj" -v quiet
  success "  openapi.json generated at $CLIENT_DIR/openapi.json"

  echo -e "\n${BOLD}[2/2] Generating TypeScript types${NC}"
  (cd "$CLIENT_DIR" && pnpm exec openapi-typescript openapi.json -o src/api/schema.d.ts)
  success "  schema.d.ts generated at $CLIENT_DIR/src/api/schema.d.ts"
}

cmd_verify() {
  header "Full Verification Gate"
  local failed=0

  echo -e "${BOLD}[1/6] Backend Build${NC}"
  if dotnet clean "$SLN" -v quiet 2>/dev/null && dotnet build "$SLN"; then
    success "  PASS"
  else
    err "  FAIL"; failed=1
  fi

  echo -e "\n${BOLD}[2/6] Generate API Types${NC}"
  if (cd "$CLIENT_DIR" && pnpm run generate:api 2>&1); then
    success "  PASS"
  else
    err "  FAIL"; failed=1
  fi

  echo -e "\n${BOLD}[3/6] Frontend Build${NC}"
  if (cd "$CLIENT_DIR" && pnpm build 2>&1); then
    success "  PASS"
  else
    err "  FAIL"; failed=1
  fi

  echo -e "\n${BOLD}[4/6] Backend Tests${NC}"
  cleanup_old_test_results
  if run_backend_tests; then
    success "  PASS"
  else
    err "  FAIL"; failed=1
  fi

  echo -e "\n${BOLD}[5/6] Frontend Tests${NC}"
  if (cd "$CLIENT_DIR" && pnpm test); then
    success "  PASS"
  else
    err "  FAIL"; failed=1
  fi

  echo -e "\n${BOLD}[6/6] Frontend Lint${NC}"
  if (cd "$CLIENT_DIR" && pnpm lint); then
    success "  PASS"
  else
    err "  FAIL"; failed=1
  fi

  echo ""
  if [ $failed -eq 0 ]; then
    success "All verification checks passed!"
  else
    err "Some checks failed. See output above."
    exit 1
  fi
}

cmd_infra() {
  local action="${1:-help}"
  shift 2>/dev/null || true

  # Show help without requiring Azure login
  if [ "$action" = "help" ] || [ "$action" = "--help" ] || [ "$action" = "-h" ]; then
    cmd_infra_help
    return
  fi

  setup_az_path
  ensure_az_login

  case "$action" in
    bootstrap)
      header "Bootstrapping Terraform State Backend"
      (cd "$INFRA_DIR/bootstrap" && run_terraform init && run_terraform apply "$@")
      ;;
    init)
      local stage="${1:-$DEFAULT_STAGE}"
      header "Initializing Stage: $stage"
      local stage_dir="$INFRA_DIR/stages/$stage"
      if [ ! -d "$stage_dir" ]; then
        err "Stage directory not found: $stage_dir"
        echo "Available stages:"
        ls -1 "$INFRA_DIR/stages/"
        exit 1
      fi
      (cd "$stage_dir" && run_terraform init "$@")
      ;;
    plan)
      local stage="${1:-$DEFAULT_STAGE}"
      shift 2>/dev/null || true
      header "Planning Stage: $stage"
      local stage_dir="$INFRA_DIR/stages/$stage"
      if [ ! -d "$stage_dir" ]; then
        err "Stage directory not found: $stage_dir"
        echo "Available stages:"
        ls -1 "$INFRA_DIR/stages/"
        exit 1
      fi
      (cd "$stage_dir" && run_terraform plan "$@")
      ;;
    apply)
      local stage="${1:-$DEFAULT_STAGE}"
      shift 2>/dev/null || true
      header "Applying Stage: $stage"
      local stage_dir="$INFRA_DIR/stages/$stage"
      if [ ! -d "$stage_dir" ]; then
        err "Stage directory not found: $stage_dir"
        echo "Available stages:"
        ls -1 "$INFRA_DIR/stages/"
        exit 1
      fi
      (cd "$stage_dir" && run_terraform apply "$@")
      ;;
    destroy)
      local stage="${1:-$DEFAULT_STAGE}"
      shift 2>/dev/null || true
      header "Destroying Stage: $stage"
      warn "WARNING: This will destroy ALL resources in stage '$stage'!"
      local stage_dir="$INFRA_DIR/stages/$stage"
      if [ ! -d "$stage_dir" ]; then
        err "Stage directory not found: $stage_dir"
        exit 1
      fi
      (cd "$stage_dir" && run_terraform destroy "$@")
      ;;
    output)
      local stage="${1:-$DEFAULT_STAGE}"
      shift 2>/dev/null || true
      local stage_dir="$INFRA_DIR/stages/$stage"
      (cd "$stage_dir" && run_terraform output "$@")
      ;;
    unlock)
      local stage="${1:-}"
      local lock_id="${2:-}"
      if [ -z "$stage" ] || [ -z "$lock_id" ]; then
        err "Usage: ./dev infra unlock <stage> <lock-id>"
        exit 1
      fi
      header "Force-unlocking Stage: $stage (Lock: $lock_id)"
      local stage_dir="$INFRA_DIR/stages/$stage"
      (cd "$stage_dir" && run_terraform force-unlock -force "$lock_id")
      ;;
    status)
      local stage="${1:-$DEFAULT_STAGE}"
      local stage_dir="$INFRA_DIR/stages/$stage"
      header "State for Stage: $stage"
      (cd "$stage_dir" && run_terraform state list 2>/dev/null) || warn "No state found for $stage"
      ;;
    *)
      err "Unknown infra action: $action"
      cmd_infra_help
      exit 1
      ;;
  esac
}

cmd_infra_help() {
  cat <<'EOF'

  Usage: ./dev infra <action> [stage] [options]

  Actions:
    bootstrap                   Create Terraform state backend in Azure
    init [stage]                Initialize Terraform for a stage
    plan [stage]                Plan infrastructure changes
    apply [stage]               Apply infrastructure changes
    destroy [stage]             Destroy all resources in a stage
    output [stage]              Show Terraform outputs
    status [stage]              List resources in state
    unlock <stage> <lock-id>    Force-unlock a stuck state lock

  Stages: stage1-mvp (default), stage2-resilience, stage3-scale

  Prerequisites:
    - Azure CLI (az) — auto-detected from PATH or common install locations
    - Terraform (>= 1.5) — auto-detected from PATH or common install locations
    - Logged into Azure: az login

  Examples:
    ./dev infra plan                   Plan stage1-mvp
    ./dev infra apply stage1-mvp       Apply stage1-mvp
    ./dev infra output stage1-mvp      Show outputs
    ./dev infra status                 List deployed resources
    ./dev infra destroy stage2-resilience

EOF
}

cmd_docker() {
  local action="${1:-up}"

  case "$action" in
    up)
      header "Starting SQL Server Docker Container"
      if docker ps --format '{{.Names}}' 2>/dev/null | grep -q 'lemondo-sqlserver'; then
        warn "Container 'lemondo-sqlserver' already running."
      else
        docker run -d --name lemondo-sqlserver \
          -e 'ACCEPT_EULA=Y' \
          -e 'MSSQL_SA_PASSWORD=YourStr0ngPassw0rd' \
          -p 1433:1433 \
          mcr.microsoft.com/mssql/server:2022-latest
        success "SQL Server started on localhost:1433"
        echo "Waiting for SQL Server to be ready..."
        sleep 5
      fi
      ;;
    down)
      header "Stopping SQL Server Docker Container"
      docker stop lemondo-sqlserver 2>/dev/null && docker rm lemondo-sqlserver 2>/dev/null
      success "SQL Server stopped and removed."
      ;;
    *)
      err "Unknown docker action: $action"
      echo "Usage: ./dev docker [up|down]"
      exit 1
      ;;
  esac
}

cmd_test_results() {
  local action="${1:-list}"

  case "$action" in
    list)
      if [ ! -d "$TEST_RESULTS_DIR" ] || [ -z "$(find "$TEST_RESULTS_DIR" -name '*.trx' 2>/dev/null)" ]; then
        warn "No test results found in .test-results/"
        return
      fi
      header "Recent Test Results (last 24h)"
      for project_dir in "$TEST_RESULTS_DIR"/*/; do
        [ -d "$project_dir" ] || continue
        local project
        project="$(basename "$project_dir")"
        local dir="$TEST_RESULTS_DIR/$project"
        [ -d "$dir" ] || continue
        local trx_files
        trx_files=$(find "$dir" -name '*.trx' 2>/dev/null | sort -r)
        [ -z "$trx_files" ] && continue

        echo -e "\n  ${BOLD}$project${NC}"
        echo -e "  ${CYAN}Timestamp              Tests   Pass    Fail${NC}"
        while IFS= read -r f; do
          local total passed failed
          total=$(grep -oP 'total="\K\d+' "$f" 2>/dev/null | head -1)
          passed=$(grep -oP 'passed="\K\d+' "$f" 2>/dev/null | head -1)
          failed=$(grep -oP 'failed="\K\d+' "$f" 2>/dev/null | head -1)
          local ts
          ts=$(stat -c '%Y' "$f" 2>/dev/null || stat -f '%m' "$f" 2>/dev/null)
          local date_str
          date_str=$(date -d "@$ts" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -r "$ts" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
          local color="$GREEN"
          [ "${failed:-0}" -gt 0 ] && color="$RED"
          printf "  ${color}%-23s %-7s %-7s %s${NC}\n" "$date_str" "${total:-?}" "${passed:-?}" "${failed:-?}"
        done <<< "$trx_files"
      done
      echo ""
      ;;
    failures)
      if [ ! -d "$TEST_RESULTS_DIR" ]; then
        warn "No test results found."
        return
      fi
      header "Failed Tests (from recent TRX files)"
      local found=0
      for project_dir in "$TEST_RESULTS_DIR"/*/; do
        [ -d "$project_dir" ] || continue
        local project
        project="$(basename "$project_dir")"
        for f in "$project_dir"*.trx; do
          [ -f "$f" ] || continue
          # Count only UnitTestResult elements with outcome=Failed (not ResultSummary)
          local fails
          fails=$(grep -c 'UnitTestResult.*outcome="Failed"' "$f" 2>/dev/null || true)
          fails="${fails:-0}"
          if [ "$fails" -gt 0 ]; then
            found=1
            echo -e "\n${RED}${BOLD}[$project]${NC} — $fails failure(s):"
            # Extract failed test names
            grep -oP 'UnitTestResult[^>]*testName="\K[^"]+(?="[^>]*outcome="Failed")' "$f" 2>/dev/null | while read -r name; do
              echo -e "  ${RED}✗${NC} $name"
            done
            # Extract assertion messages (inside <Message> tags)
            grep -oP '<Message>\K[^<]+' "$f" 2>/dev/null | while read -r msg; do
              echo -e "    ${YELLOW}→ ${msg}${NC}"
            done
          fi
        done
      done
      if [ "$found" -eq 0 ]; then
        success "No failures found in recent results."
      fi
      ;;
    clean)
      header "Cleaning All Test Results"
      rm -rf "$TEST_RESULTS_DIR"
      success "Test results cleaned."
      ;;
    *)
      err "Unknown test-results action: $action"
      echo "Usage: ./dev test-results [list|failures|clean]"
      exit 1
      ;;
  esac
}

cmd_help() {
  cat <<'EOF'

  LemonDo Developer CLI

  Usage: ./dev <command> [options]

  Commands:

    install                   Install deps + generate dev config + API types
    build                     Clean + build all projects (0 warnings gate)
    generate                  Regenerate OpenAPI spec + TypeScript types
    verify                    Full verification gate (build + tests + lint)

    test [target]             Run tests
      all                     Backend (SQLite) + Frontend (default)
      backend                 Backend tests (SQLite)
      backend:sql             Backend tests (SQL Server)
      backend:both            Backend tests (SQLite then SQL Server)
      frontend                Frontend tests (Vitest)
      e2e                     E2E tests (Playwright, SQLite)
      e2e:sql                 E2E tests (Playwright, SQL Server)
      e2e:headed              E2E tests with browser visible
      e2e:ui                  E2E Playwright UI mode
      e2e:update-snapshots    Regenerate visual regression snapshots

    lint                      Frontend ESLint

    test-results [action]     Browse test result logs (24h retention)
      list                    Show recent results summary (default)
      failures                Show failed tests with messages
      clean                   Delete all stored results

    start [target]            Start services
      all                     Full stack via Aspire (default)
      api                     API only
      frontend                Frontend dev server only

    migrate <action> [args]   EF Core migrations
      add <name>              Add migration to BOTH providers
      list [sqlite|sqlserver] List migrations for a provider
      remove <sqlite|sql>     Remove last migration for a provider

    docker [action]           SQL Server Docker container
      up                      Start container (default)
      down                    Stop and remove container

    infra <action> [stage]    Azure infrastructure (Terraform)
      bootstrap               Create state backend in Azure
      init [stage]            Initialize Terraform for a stage
      plan [stage]            Plan infrastructure changes
      apply [stage]           Apply infrastructure changes
      destroy [stage]         Destroy all resources in a stage
      output [stage]          Show Terraform outputs
      status [stage]          List resources in state
      unlock <stage> <id>     Force-unlock a stuck state lock

    help                      Show this help

  Stages: stage1-mvp (default), stage2-resilience, stage3-scale

  Examples:
    ./dev install
    ./dev build
    ./dev test backend
    ./dev test backend:sql
    ./dev test e2e
    ./dev test e2e:headed
    ./dev test e2e:update-snapshots
    ./dev start
    ./dev start api
    ./dev migrate add AddNewColumn
    ./dev migrate list sqlserver
    ./dev verify
    ./dev docker up
    ./dev infra plan
    ./dev infra apply stage1-mvp
    ./dev infra output

EOF
}

# ── Main dispatch ─────────────────────────────────────────────────────
command="${1:-help}"
shift 2>/dev/null || true

# Strip bare '--' separators so passthrough args reach subcommands cleanly.
# e.g. ./dev test e2e -- --project=chromium → cmd_test receives: e2e --project=chromium
args=()
for arg in "$@"; do
  [[ "$arg" == "--" ]] || args+=("$arg")
done
set -- "${args[@]+"${args[@]}"}"

case "$command" in
  install)     cmd_install "$@" ;;
  build)       cmd_build "$@" ;;
  test)        cmd_test "$@" ;;
  test-results) cmd_test_results "$@" ;;
  lint)        cmd_lint "$@" ;;
  start)       cmd_start "$@" ;;
  migrate)     cmd_migrate "$@" ;;
  verify)      cmd_verify "$@" ;;
  generate)    cmd_generate "$@" ;;
  docker)      cmd_docker "$@" ;;
  infra)       cmd_infra "$@" ;;
  help|--help|-h)  cmd_help ;;
  *)
    err "Unknown command: $command"
    cmd_help
    exit 1
    ;;
esac
